fun day1_secret_entrance() {
    sample = "
        L68
        L30
        R48
        L5
        R60
        L55
        L1
        L99
        R14
        L82
    "

    # The built-in Turn::parse expects inputs separated by whitespace
    fun normalize_input(s: str): str {
        (dir, num) = s.trim().split_at(1)
        return "$dir $num"
    }

    rec Turn(dir: str, count: int)

    turns = sample.trim()
        .lines()
        .map(normalize_input)
        .map(Turn::parse)

    seq = turns.scan(
        fun(last: int, turn: Turn) {
            match turn.dir {
                "L" { { last - turn.count } % 100 }
                "R" { { last + turn.count } % 100 }
                _ { last }
            }
        }
        initial: 50
    )

    password = seq.count(0)

    assert password == 3
}

fun day2_gift_shop() {
    sample = "11-22,95-115,998-1012,1188511880-1188511890,222220-222224,1698522-1698528,446443-446449,38593856-38593862,565653-565659,824824821-824824827,2121212118-2121212124"

    inputs = sample.split(",").map(Range::parse)

    fun is_invalid(id: int): bool {
        id_str = "$id"
        (l, r) = id_str.split_at(id_str.len() / 2)
        return l == r
    }

    total = inputs
        .flatten()
        .filter(is_invalid)
        .sum()

    assert total == 1227775554
}

fun day3_lobby() {
    # The batteries are arranged into banks; each line of digits in your input
    # corresponds to a single bank of batteries. Within each bank, you need to
    # turn on exactly two batteries; the joltage that the bank produces is
    # equal to the number formed by the digits on the batteries you've turned
    # on. For example, if you have a bank like 12345 and you turn on batteries
    # 2 and 4, the bank would produce 24 jolts. (You cannot rearrange
    # batteries.)
    #
    # You'll need to find the largest possible joltage each bank can produce.
    # In the above example:
    #
    #     In 987654321111111, you can make the largest joltage possible, 98, by
    #           turning on the first two batteries.
    #     In 811111111111119, you can make the largest joltage possible by
    #           turning on the batteries labeled 8 and 9, producing 89 jolts.
    #     In 234234234234278, you can make 78 by turning on the last two
    #           batteries (marked 7 and 8).
    #     In 818181911112111, the largest joltage you can produce is 92.
    #
    # The total output joltage is the sum of the maximum joltage from each
    # bank, so in this example, the total output joltage is 98 + 89 + 78 + 92 =
    # 357.
    #
    # There are many batteries in front of you. Find the maximum joltage
    # possible from each bank; what is the total output joltage?

    sample = "
        987654321111111
        811111111111119
        234234234234278
        818181911112111
    "

    fun find_max_joltage(bank: str): int? {
        nums = bank.trim().chars().map(int::parse)
        msd = nums.take(nums.len() - 1).max()?
        msd_idx = nums.find_index(msd)?
        lsd = nums.skip(msd_idx + 1).max()?
        return msd * 10 + lsd
    }

    answer = sample.trim().lines()
        .map(fun(bank) { find_max_joltage(bank) ?? 0 })
        .sum()

    assert answer == 357
}

fun day4_printing_department() {
    # The rolls of paper (@) are arranged on a large grid; the Elves even have
    # a helpful diagram (your puzzle input) indicating where everything is
    # located.
    #
    # For example:
    #
    # ..@@.@@@@.
    # @@@.@.@.@@
    # @@@@@.@.@@
    # @.@@@@..@.
    # @@.@@@@.@@
    # .@@@@@@@.@
    # .@.@.@.@@@
    # @.@@@.@@@@
    # .@@@@@@@@.
    # @.@.@@@.@.
    #
    # The forklifts can only access a roll of paper if there are fewer than
    # four rolls of paper in the eight adjacent positions. If you can figure
    # out which rolls of paper the forklifts can access, they'll spend less
    # time looking and more time breaking down the wall to the cafeteria.
    #
    # In this example, there are 13 rolls of paper that can be accessed by a
    # forklift (marked with x):
    #
    # ..xx.xx@x.
    # x@@.@.@.@@
    # @@@@@.x.@@
    # @.@@@@..@.
    # x@.@@@@.@x
    # .@@@@@@@.@
    # .@.@.@.@@@
    # x.@@@.@@@@
    # .@@@@@@@@.
    # x.x.@@@.x.
    #
    # Consider your complete diagram of the paper roll locations. How many
    # rolls of paper can be accessed by a forklift?

    sample = "
        ..@@.@@@@.
        @@@.@.@.@@
        @@@@@.@.@@
        @.@@@@..@.
        @@.@@@@.@@
        .@@@@@@@.@
        .@.@.@.@@@
        @.@@@.@@@@
        .@@@@@@@@.
        @.@.@@@.@.
    "

    # Parse input
    grid = sample.trim().lines().map(fun(line) { line.trim().chars() })

    rec Coord(l: int, c: int)

    fun all_coords(rows: range, cols: range) {
        List::cartesian(rows.to_list(), cols.to_list()).map_to(Coord)
    }

    fun is_roll(coord: Coord): bool {
        if line in grid.at(coord.l) {
            if ch in line.at(coord.c) {
                return ch == "@"
            }
        }
        return false
    }

    fun adjacent_roll_count(ch: Coord): int {
        adjacent_coords = all_coords(
            ch.l-1..ch.l+1
            ch.c-1..ch.c+1
        )

        return adjacent_coords.filter(is_roll).len()
    }

    height = grid.len()
    width = grid.at(0).len() ?? 0
    answer = all_coords(0..height, 0..width)
        .filter(fun(coord) {
            is_roll(coord) && adjacent_roll_count(coord) <= 4
        })
        .len()

    assert answer == 13
}
