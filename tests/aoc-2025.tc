fun day1_secret_entrance() {
    sample = "
        L68
        L30
        R48
        L5
        R60
        L55
        L1
        L99
        R14
        L82
    "

    # The built-in Turn::parse expects inputs separated by whitespace
    fun normalize_input(s: str): str {
        (dir, num) = s.trim().split_at(1)
        return "$dir $num"
    }

    rec Turn(dir: str, count: int)

    turns = sample.trim()
        .lines()
        .map(normalize_input)
        .map(fun(s) { Turn::parse(s)! })

    seq = turns.scan(
        fun(last: int, turn: Turn) {
            match? turn.dir {
                "L" { { last - turn.count } % 100 }
                "R" { { last + turn.count } % 100 }
            }!
        }
        initial: 50
    )

    password = seq.count(0)

    assert password == 3
}

fun day2_gift_shop() {
    sample = "11-22,95-115,998-1012,1188511880-1188511890,222220-222224,1698522-1698528,446443-446449,38593856-38593862,565653-565659,824824821-824824827,2121212118-2121212124"

    inputs = sample.split(",").map(Range::parse)

    fun is_invalid(id: int): bool {
        id_str = "$id"
        (l, r) = id_str.split_at(id_str.len() / 2)
        return l == r
    }

    total = inputs
        .flatten()
        .filter(is_invalid)
        .sum()

    assert total == 1227775554
}

fun day3_lobby() {
    # The batteries are arranged into banks; each line of digits in your input
    # corresponds to a single bank of batteries. Within each bank, you need to
    # turn on exactly two batteries; the joltage that the bank produces is
    # equal to the number formed by the digits on the batteries you've turned
    # on. For example, if you have a bank like 12345 and you turn on batteries
    # 2 and 4, the bank would produce 24 jolts. (You cannot rearrange
    # batteries.)
    #
    # You'll need to find the largest possible joltage each bank can produce.
    # In the above example:
    #
    #     In 987654321111111, you can make the largest joltage possible, 98, by
    #           turning on the first two batteries.
    #     In 811111111111119, you can make the largest joltage possible by
    #           turning on the batteries labeled 8 and 9, producing 89 jolts.
    #     In 234234234234278, you can make 78 by turning on the last two
    #           batteries (marked 7 and 8).
    #     In 818181911112111, the largest joltage you can produce is 92.
    #
    # The total output joltage is the sum of the maximum joltage from each
    # bank, so in this example, the total output joltage is 98 + 89 + 78 + 92 =
    # 357.
    #
    # There are many batteries in front of you. Find the maximum joltage
    # possible from each bank; what is the total output joltage?

    sample = "
        987654321111111
        811111111111119
        234234234234278
        818181911112111
    "

    fun find_max_joltage(bank: str): int? {
        nums = bank.trim().chars().map(int::parse)
        msd = nums.take(nums.len() - 1).max()?
        msd_idx = nums.find_index(msd)?
        lsd = nums.skip(msd_idx + 1).max()?
        return msd * 10 + lsd
    }

    answer = sample.trim().lines()
        .map(fun(bank) { find_max_joltage(bank) ?? 0 })
        .sum()

    assert answer == 357
}

fun day4_printing_department() {
    # The rolls of paper (@) are arranged on a large grid; the Elves even have
    # a helpful diagram (your puzzle input) indicating where everything is
    # located.
    #
    # For example:
    #
    # ..@@.@@@@.
    # @@@.@.@.@@
    # @@@@@.@.@@
    # @.@@@@..@.
    # @@.@@@@.@@
    # .@@@@@@@.@
    # .@.@.@.@@@
    # @.@@@.@@@@
    # .@@@@@@@@.
    # @.@.@@@.@.
    #
    # The forklifts can only access a roll of paper if there are fewer than
    # four rolls of paper in the eight adjacent positions. If you can figure
    # out which rolls of paper the forklifts can access, they'll spend less
    # time looking and more time breaking down the wall to the cafeteria.
    #
    # In this example, there are 13 rolls of paper that can be accessed by a
    # forklift (marked with x):
    #
    # ..xx.xx@x.
    # x@@.@.@.@@
    # @@@@@.x.@@
    # @.@@@@..@.
    # x@.@@@@.@x
    # .@@@@@@@.@
    # .@.@.@.@@@
    # x.@@@.@@@@
    # .@@@@@@@@.
    # x.x.@@@.x.
    #
    # Consider your complete diagram of the paper roll locations. How many
    # rolls of paper can be accessed by a forklift?

    sample = "
        ..@@.@@@@.
        @@@.@.@.@@
        @@@@@.@.@@
        @.@@@@..@.
        @@.@@@@.@@
        .@@@@@@@.@
        .@.@.@.@@@
        @.@@@.@@@@
        .@@@@@@@@.
        @.@.@@@.@.
    "

    # Parse input
    grid = sample.trim().lines().map(fun(line) { line.trim().chars() })

    rec Coord(l: int, c: int)

    fun is_roll(coord: Coord): bool {
        if line in grid.at(coord.l) {
            if ch in line.at(coord.c) {
                return ch == "@"
            }
        }
        return false
    }

    fun adjacent_roll_count(ch: Coord): int {
        List::cartesian(ch.l-1 .. ch.l+1, ch.c-1 .. ch.c+1)
            .map_to(Coord)
            .filter(is_roll)
            .len()
    }

    height = grid.len()
    width = grid.at(0)!.len()
    answer = List::cartesian(0..height-1, 0..width-1)
        .map_to(Coord)
        .filter(fun(coord) {
            is_roll(coord) && adjacent_roll_count(coord) <= 4
        })
        .len()

    assert answer == 13
}

fun day5_cafeteria() {
    # The database operates on ingredient IDs. It consists of a list of fresh
    # ingredient ID ranges, a blank line, and a list of available ingredient
    # IDs. For example:
    #
    # 3-5
    # 10-14
    # 16-20
    # 12-18
    #
    # 1
    # 5
    # 8
    # 11
    # 17
    # 32
    #
    # The fresh ID ranges are inclusive: the range 3-5 means that ingredient
    # IDs 3, 4, and 5 are all fresh. The ranges can also overlap; an ingredient
    # ID is fresh if it is in any range.
    #
    # The Elves are trying to determine which of the available ingredient IDs
    # are fresh. In this example, this is done as follows:
    #
    # Ingredient ID 1 is spoiled because it does not fall into any range.
    # Ingredient ID 5 is fresh because it falls into range 3-5.
    # Ingredient ID 8 is spoiled.
    # Ingredient ID 11 is fresh because it falls into range 10-14.
    # Ingredient ID 17 is fresh because it falls into range 16-20 as well as range 12-18.
    # Ingredient ID 32 is spoiled.
    # So, in this example, 3 of the available ingredient IDs are fresh.
    #
    # Process the database file from the new inventory management system. How
    # many of the available ingredient IDs are fresh?

    sample = """
3-5
10-14
16-20
12-18

1
5
8
11
17
32
    """

    fun split_blank(lines: [str]): ([str], [str]) {
        split = lines.find_index("")!

        return (lines.take(split), lines.skip(split + 1))
    }

    fun parse_input(input: str): ([range], [int]) {
        (lhs, rhs) = split_blank(input.trim().lines())

        return (
            lhs.map(Range::parse)
            rhs.map(int::parse)
        )
    }

    (ranges, ids) = parse_input(sample)

    fresh = ids.filter(fun(id) {
        ranges.any(fun(r) { r.contains(id) })
    }).len()

    assert fresh == 3
}

fun day6_trash_compactor__zip4() {
    # Cephalopod math doesn't look that different from normal math. The math
    # worksheet (your puzzle input) consists of a list of problems; each
    # problem has a group of numbers that need to be either added (+) or
    # multiplied (*) together.
    #
    # However, the problems are arranged a little strangely; they seem to be
    # presented next to each other in a very long horizontal list. For example:
    #
    # 123 328  51 64
    #  45 64  387 23
    #   6 98  215 314
    # *   +   *   +
    #
    # Each problem's numbers are arranged vertically; at the bottom of the
    # problem is the symbol for the operation that needs to be performed.
    # Problems are separated by a full column of only spaces. The left/right
    # alignment of numbers within each problem can be ignored.
    #
    # So, this worksheet contains four problems:
    #
    # 123 * 45 * 6 = 33210
    # 328 + 64 + 98 = 490
    # 51 * 387 * 215 = 4243455
    # 64 + 23 + 314 = 401
    #
    # To check their work, cephalopod students are given the grand total of
    # adding together all of the answers to the individual problems. In this
    # worksheet, the grand total is 33210 + 490 + 4243455 + 401 = 4277556.

    sample = """
        123 328  51 64
         45 64  387 23
          6 98  215 314
        *   +   *   +
    """

    input = sample.trim().lines().map(fun(l) { l.split(" ", skip_empty: true) })
    assert input.len() == 4

    input = List::zip4(
        input.at(0)!.map(int::parse)
        input.at(1)!.map(int::parse)
        input.at(2)!.map(int::parse)
        input.at(3)!
    )

    res = input.map_to(fun(a, b, c, op) {
        match? op {
            "+" { a + b + c }
            "*" { a * b * c }
        }!
    }).sum()

    assert res == 4277556
}

fun day6_trash_compactor__list_flip() {
    sample = """
        123 328  51 64
         45 64  387 23
          6 98  215 314
        *   +   *   +
    """

    input = sample.trim().lines().map(fun(l) { l.split(" ", skip_empty: true) })
    assert input.len() == 4

    input = input.flip().map(fun(p) {
        (
            int::parse(p.at(0)!)
            int::parse(p.at(1)!)
            int::parse(p.at(2)!)
            p.at(3)!
        )
    })

    res = input.map_to(fun(a, b, c, op) {
        match? op {
            "+" { a + b + c }
            "*" { a * b * c }
        }!
    }).sum()

    assert res == 4277556
}
