fun test_parse_int() {
    assert int::parse("234") == 234
}

fun test_parse_range() {
    assert Range::parse("234-345") == 234..345
}

# TODO Equality for Rec
# Must recursively check that all values support equality, during validation
# This will be similar to automatically deriging PartialEq in Rust

fun test_parse_unnamed_record() {
    rec Point(int, int)

    res = Point::parse("100 200")

    assert res.is_ok()

    p = res.value()!
    assert "$p" == "Point(100, 200)"
}

fun test_parse_named_record() {
    rec Point(x: int, y: int)

    res = Point::parse("100 200")

    assert res.is_ok()

    p = res.value()!
    assert p.x == 100
    assert p.y == 200
    assert "$p" == "Point(x: 100, y: 200)"
}

fun test_parse_list() {
    rec Point(int, int)

    input = [
        "100  200"
        "400  600"
        "0 0"
    ]

    points = input.map(Point::parse)

    assert "$points" == "[Ok(Point(100, 200)), Ok(Point(400, 600)), Ok(Point(0, 0))]"
}

fun test_parse_str_and_int() {
    rec Point(a: str, b: int)

    res = Point::parse("L 200")
    assert res.is_ok()

    p = res.value()!
    assert "$p" == "Point(a: L, b: 200)"
}

fun test_parse_error() {
    rec Point(a: int, b: int)

    res = Point::parse("xyz")

    assert res.is_err()
    assert res.error().is_some()
    assert res.value().is_none()
}
